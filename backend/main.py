import asyncpg
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import bcrypt
import hashlib
from typing import List
from fpdf import FPDF
import datetime
import zipfile
import re 
import secrets
import os
import tempfile
import ssl # NEW: Required for Cloud Handshakes
from jose import JWTError, jwt

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- SECURITY CONFIG ---
SECRET_KEY = "aegis_top_secret_key_change_this_in_production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# --- DATABASE CONFIG ---
PII_KEYWORDS = ['name', 'email', 'ssn', 'social', 'phone', 'mobile', 'addr', 'city', 'zip', 'card', 'credit']
SAFE_KEYWORDS = ['id', 'date', 'time', 'amount', 'balance', 'price', 'merchant', 'status', 'code', 'type', 'sku']
REGEX_PATTERNS = {
    'EMAIL': r'^[\w\.-]+@[\w\.-]+\.\w+$',
    'PHONE': r'^\+?1?\d{9,15}$',
    'CREDIT_CARD': r'^\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}$',
    'SSN': r'^\d{3}-?\d{2}-?\d{4}$'
}
# KEEPING LOCAL DB FOR AUDITS
AEGIS_DB_DSN = "postgresql://postgres:root@localhost:5432/aegisdb"

# --- MODELS ---
class ConnectionDetails(BaseModel):
    db_name: str
    user: str
    password: str
    host: str = "localhost"
    port: str = "5432"
    ssl_enabled: bool = False # NEW: Toggle for Cloud Mode

class BulkSearchRequest(BaseModel):
    connection: ConnectionDetails
    table_name: str
    primary_key_col: str
    target_ids: List[str]

class BulkErasureRequest(BaseModel):
    connection: ConnectionDetails
    target_table: str
    target_id_col: str
    target_ids: List[str]
    columns_to_clean: List[dict] 

# --- SECURITY HELPERS ---
def verify_password(plain_password: str, hashed_password: str):
    password_byte = plain_password.encode('utf-8')
    if isinstance(hashed_password, str):
        hash_byte = hashed_password.encode('utf-8')
    else:
        hash_byte = hashed_password
    return bcrypt.checkpw(password_byte, hash_byte)

def create_access_token(data: dict):
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None: raise credentials_exception
    except JWTError:
        raise credentials_exception
    return username

# --- CORE HELPERS ---
def build_dsn(c: ConnectionDetails):
    return f"postgresql://{c.user}:{c.password}@{c.host}:{c.port}/{c.db_name}"

# NEW: SSL CONTEXT GENERATOR
def get_ssl_context(enabled: bool):
    if not enabled:
        return None # Localhost doesn't need SSL
    
    # Create a context that requires Encryption but accepts the Cloud Provider's CA
    # equivalent to 'sslmode=require' or 'verify-ca'
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE 
    return ctx

def remove_file(path: str):
    try: os.unlink(path)
    except: pass

def create_certificate(db_name, table_name, record_id, original_data, columns_cleaned, timestamp, salt, admin_user):
    try:
        pdf = FPDF()
        pdf.add_page()
        pdf.rect(5, 5, 200, 287, 'D')
        
        pdf.set_font("Times", 'B', 24)
        pdf.cell(190, 20, txt="CERTIFICATE OF ERASURE", ln=1, align='C')
        
        pdf.set_font("Arial", 'I', 10)
        pdf.cell(190, 5, txt="Generated by Aegis Sovereignty Engine v3.0 (Cloud Enabled)", ln=1, align='C')
        pdf.line(20, 35, 190, 35)
        pdf.ln(15)
        
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(190, 10, txt="EXECUTION METADATA", ln=1, align='L')
        pdf.set_font("Arial", size=11)
        
        def add_row(label, value):
            pdf.set_font("Arial", 'B', 11)
            pdf.cell(50, 8, txt=label, border=1)
            pdf.set_font("Arial", size=11)
            pdf.cell(140, 8, txt=str(value), border=1, ln=1)

        add_row("Execution Timestamp", timestamp)
        add_row("Authorized Admin", admin_user)
        add_row("Target Database", db_name)
        add_row("Target Table", table_name)
        add_row("Record ID", str(record_id))
        add_row("Cryptographic Salt", salt) 
        
        pdf.ln(10)
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(190, 10, txt="PRE-ERASURE SNAPSHOT", ln=1, align='L')
        pdf.set_font("Courier", size=10) 
        
        for col in columns_cleaned:
            c_name = str(col['col'])
            strategy = str(col['strategy'])
            val = str(original_data.get(c_name, 'NULL')).encode('latin-1', 'replace').decode('latin-1')
            pdf.cell(60, 6, txt=c_name, border=1)
            pdf.cell(130, 6, txt=f"[{strategy}] {val}", border=1, ln=1)

        pdf.ln(10)
        pdf.set_font("Times", '', 12)
        pdf.multi_cell(190, 6, txt="This document certifies that PII has been irreversibly pseudonymized or masked according to the defined strategy.")
        
        output = pdf.output(dest='S')
        if isinstance(output, str): return output.encode('latin-1', 'replace')
        return output
    except Exception as e:
        print(f"[DEBUG] PDF Error: {e}")
        return b"Error"

# --- AUTH ENDPOINT ---
@app.post("/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    conn = await asyncpg.connect(AEGIS_DB_DSN)
    try:
        user = await conn.fetchrow("SELECT * FROM administrators WHERE username = $1", form_data.username)
        if not user or not verify_password(form_data.password, user['password_hash']):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token = create_access_token(data={"sub": user['username']})
        return {"access_token": access_token, "token_type": "bearer"}
    finally:
        await conn.close()

# --- PROTECTED ENDPOINTS ---

@app.post("/scan-target", dependencies=[Depends(get_current_user)])
async def scan_target_database(conn_details: ConnectionDetails):
    dsn = build_dsn(conn_details)
    ssl_ctx = get_ssl_context(conn_details.ssl_enabled) # GET SSL
    
    try:
        # CONNECT WITH SSL
        conn = await asyncpg.connect(dsn, ssl=ssl_ctx)
        try:
            query_cols = "SELECT table_name, column_name, data_type FROM information_schema.columns WHERE table_schema = 'public' ORDER BY table_name, ordinal_position;"
            rows = await conn.fetch(query_cols)
            
            query_pk = """SELECT kcu.table_name, kcu.column_name FROM information_schema.table_constraints tco JOIN information_schema.key_column_usage kcu ON kcu.constraint_name = tco.constraint_name AND kcu.table_schema = tco.table_schema WHERE tco.constraint_type = 'PRIMARY KEY';"""
            pk_rows = await conn.fetch(query_pk)
            pk_map = {r['table_name']: r['column_name'] for r in pk_rows}

            schema_map = {}
            for r in rows:
                tbl = r['table_name']
                col = r['column_name'].lower()
                dtype = r['data_type']
                strategy = "IGNORE"
                reason = "Default"

                if any(k in col for k in SAFE_KEYWORDS): 
                    strategy = "PRESERVE"; reason = "Safe Keyword"
                elif 'email' in col:
                    strategy = "EMAIL_MASK"; reason = "Email Detected"
                elif 'card' in col or 'ssn' in col or 'phone' in col:
                    strategy = "MASK"; reason = "Sensitive ID"
                elif any(k in col for k in PII_KEYWORDS) and dtype in ['text', 'character varying']: 
                    strategy = "HASH"; reason = "Generic PII"
                
                if strategy == "IGNORE" and dtype in ['text', 'character varying']:
                    try:
                        sample_q = f"SELECT {r['column_name']} FROM {tbl} WHERE {r['column_name']} IS NOT NULL LIMIT 5"
                        samples = await conn.fetch(sample_q)
                        for s_row in samples:
                            val = str(s_row[0])
                            for p_name, p_regex in REGEX_PATTERNS.items():
                                if re.match(p_regex, val):
                                    strategy = "HASH"; reason = f"Deep Scan: {p_name}"; break
                            if strategy == "HASH": break
                    except: pass

                if tbl not in schema_map: 
                    schema_map[tbl] = {"primary_key": pk_map.get(tbl, "UNKNOWN"), "columns": []}
                schema_map[tbl]["columns"].append({"name": r['column_name'], "type": dtype, "suggested_strategy": strategy, "reason": reason})
            return {"status": "connected", "schema": schema_map}
        finally:
            await conn.close()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Connection Failed: {str(e)}")

@app.post("/fetch-batch-details", dependencies=[Depends(get_current_user)])
async def fetch_batch_details(req: BulkSearchRequest):
    dsn = build_dsn(req.connection)
    ssl_ctx = get_ssl_context(req.connection.ssl_enabled) # GET SSL
    
    try:
        conn = await asyncpg.connect(dsn, ssl=ssl_ctx)
        try:
            query = f"SELECT * FROM {req.table_name} WHERE {req.primary_key_col}::text = ANY($1::text[])"
            rows = await conn.fetch(query, req.target_ids)
            results = []
            for row in rows:
                data = dict(row)
                for k, v in data.items(): data[k] = str(v)
                results.append(data)
            return results
        finally:
            await conn.close()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/execute-erasure")
async def execute_erasure(req: BulkErasureRequest, background_tasks: BackgroundTasks, current_user: str = Depends(get_current_user)):
    print(f"[DEBUG] Admin '{current_user}' processing {len(req.target_ids)} records...")
    
    timestamp = str(datetime.datetime.now())
    clean_time = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    session_salt = secrets.token_hex(8) 

    try:
        target_dsn = build_dsn(req.connection)
        ssl_ctx = get_ssl_context(req.connection.ssl_enabled) # GET SSL
        
        conn = await asyncpg.connect(target_dsn, ssl=ssl_ctx) # CONNECT SECURELY
        
        # Local DB doesn't need SSL usually, but we assume local for logs
        aegis_conn = await asyncpg.connect(AEGIS_DB_DSN)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB Connection Error: {e}")

    temp_zip = tempfile.NamedTemporaryFile(delete=False, suffix=".zip")
    temp_zip_path = temp_zip.name
    temp_zip.close()

    try:
        with zipfile.ZipFile(temp_zip_path, "w", zipfile.ZIP_DEFLATED) as zip_file:
            
            for target_id in req.target_ids:
                try:
                    fetch_q = f"SELECT * FROM {req.target_table} WHERE {req.target_id_col}::text = $1"
                    row = await conn.fetchrow(fetch_q, str(target_id))
                    if not row: continue
                    original_data = dict(row)

                    async with conn.transaction():
                        for col_rule in req.columns_to_clean:
                            col = col_rule['col']
                            strategy = col_rule.get('strategy', 'HASH')
                            
                            if strategy == 'HASH':
                                sql = f"UPDATE {req.target_table} SET {col} = 'HASH_' || md5('{session_salt}' || {col}::text) WHERE {req.target_id_col}::text = $1"
                            elif strategy == 'MASK':
                                sql = f"UPDATE {req.target_table} SET {col} = '***-***-' || right({col}::text, 4) WHERE {req.target_id_col}::text = $1"
                            elif strategy == 'EMAIL_MASK':
                                sql = f"UPDATE {req.target_table} SET {col} = 'REDACTED_' || substring(md5({col}::text) from 1 for 6) || substring({col}::text from position('@' in {col}::text)) WHERE {req.target_id_col}::text = $1"
                            else:
                                continue 

                            await conn.execute(sql, str(target_id))

                    cols_str = ", ".join([c['col'] for c in req.columns_to_clean])
                    
                    try: pk_int = int(target_id)
                    except: pk_int = 0
                        
                    await aegis_conn.execute("""
                        INSERT INTO audit_logs (target_db, target_table, target_pk_id, columns_cleaned, status)
                        VALUES ($1, $2, $3, $4, 'SUCCESS')
                    """, req.connection.db_name, req.target_table, pk_int, cols_str)

                    pdf_bytes = create_certificate(req.connection.db_name, req.target_table, target_id, original_data, req.columns_to_clean, timestamp, session_salt, current_user)
                    zip_file.writestr(f"Certificate_{target_id}.pdf", pdf_bytes)

                except Exception as e:
                    print(f"Error on ID {target_id}: {e}")
                    continue

    finally:
        await conn.close()
        await aegis_conn.close()

    background_tasks.add_task(remove_file, temp_zip_path)
    return FileResponse(temp_zip_path, media_type="application/zip", filename=f"AEGIS_Batch_{clean_time}.zip")