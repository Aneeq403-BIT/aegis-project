import asyncpg
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
from typing import List
from fpdf import FPDF
import io
import datetime

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- CONFIGURATION ---
PII_KEYWORDS = ['name', 'email', 'ssn', 'social', 'phone', 'mobile', 'addr', 'city', 'zip']
SAFE_KEYWORDS = ['id', 'date', 'time', 'amount', 'balance', 'price', 'merchant', 'status']

# !!! CHECK THIS PASSWORD !!!
# If your local DB password is NOT 'root', change it here.
AEGIS_DB_DSN = "postgresql://postgres:root@localhost:5432/aegisdb"

# --- MODELS ---
class ConnectionDetails(BaseModel):
    db_name: str
    user: str
    password: str
    host: str = "localhost"
    port: str = "5432"

class SearchRequest(BaseModel):
    connection: ConnectionDetails
    table_name: str
    primary_key_col: str
    search_id: int

class ErasureRequest(BaseModel):
    connection: ConnectionDetails
    target_table: str
    target_id_col: str
    target_id_val: int
    columns_to_clean: List[dict] 

def build_dsn(c: ConnectionDetails):
    return f"postgresql://{c.user}:{c.password}@{c.host}:{c.port}/{c.db_name}"

# --- HELPER: PDF GENERATOR (FIXED) ---
def create_certificate(req: ErasureRequest, timestamp: str):
    try:
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)
        
        # Header
        pdf.set_font("Arial", 'B', 16)
        pdf.cell(200, 10, txt="CERTIFICATE OF ERASURE", ln=1, align='C')
        pdf.ln(10)
        
        # Content
        pdf.set_font("Arial", size=12)
        pdf.cell(200, 10, txt=f"Date of Execution: {timestamp}", ln=1)
        
        # Safe string handling
        db_name = str(req.connection.db_name)
        tbl_name = str(req.target_table)
        
        pdf.cell(200, 10, txt=f"Target Database: {db_name}", ln=1)
        pdf.cell(200, 10, txt=f"Table Affected: {tbl_name}", ln=1)
        pdf.cell(200, 10, txt=f"Record ID: {req.target_id_val}", ln=1)
        pdf.ln(10)
        
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(200, 10, txt="Fields Cryptographically Hashed:", ln=1)
        pdf.set_font("Arial", size=10)
        for col in req.columns_to_clean:
            c_name = str(col['col'])
            pdf.cell(200, 8, txt=f"- {c_name} (Strategy: {col['strategy']})", ln=1)
            
        pdf.ln(20)
        pdf.set_font("Arial", 'I', 10)
        pdf.cell(200, 10, txt="This document certifies that the PII data associated with this record", ln=1)
        pdf.cell(200, 10, txt="has been pseudonymized in accordance with GDPR Article 4(5).", ln=1)
        pdf.cell(200, 10, txt="Generated by Aegis Sovereignty Engine v2.2", ln=1, align='C')
        
        # COMPATIBILITY FIX: Handle difference between fpdf versions
        output = pdf.output(dest='S')
        if isinstance(output, str):
            return output.encode('latin-1', 'replace')
        return output # It's already bytes
    except Exception as e:
        print(f"[DEBUG] PDF Generation Error: {e}")
        return b"Error generating PDF"

# --- ENDPOINTS ---

@app.post("/scan-target")
async def scan_target_database(conn_details: ConnectionDetails):
    dsn = build_dsn(conn_details)
    try:
        conn = await asyncpg.connect(dsn)
        try:
            query = "SELECT table_name, column_name, data_type FROM information_schema.columns WHERE table_schema = 'public' ORDER BY table_name, ordinal_position;"
            rows = await conn.fetch(query)
            schema_map = {}
            for r in rows:
                tbl = r['table_name']
                col = r['column_name'].lower()
                dtype = r['data_type']
                strategy = "IGNORE"
                if any(k in col for k in SAFE_KEYWORDS): strategy = "PRESERVE"
                elif any(k in col for k in PII_KEYWORDS) and dtype in ['text', 'character varying']: strategy = "HASH"
                
                if tbl not in schema_map: schema_map[tbl] = []
                schema_map[tbl].append({"name": r['column_name'], "type": dtype, "suggested_strategy": strategy})
            return {"status": "connected", "schema": schema_map}
        finally:
            await conn.close()
    except Exception as e:
        print(f"[DEBUG] Scan Error: {e}")
        raise HTTPException(status_code=400, detail=f"Connection Failed: {str(e)}")

@app.post("/search-victim")
async def search_victim(req: SearchRequest):
    dsn = build_dsn(req.connection)
    try:
        conn = await asyncpg.connect(dsn)
        try:
            query = f"SELECT * FROM {req.table_name} WHERE {req.primary_key_col} = $1"
            row = await conn.fetchrow(query, req.search_id)
            if not row: return {"found": False}
            data = dict(row)
            for k, v in data.items(): data[k] = str(v)
            return {"found": True, "data": data}
        finally:
            await conn.close()
    except Exception as e:
        print(f"[DEBUG] Search Error: {e}")
        return {"found": False, "error": str(e)}

@app.post("/execute-erasure")
async def execute_erasure(req: ErasureRequest):
    print(f"[DEBUG] Starting Erasure for ID {req.target_id_val}...")

    # STEP 1: EXECUTE UPDATE ON TARGET DB
    try:
        target_dsn = build_dsn(req.connection)
        conn = await asyncpg.connect(target_dsn)
        try:
            async with conn.transaction():
                for col_rule in req.columns_to_clean:
                    col = col_rule['col']
                    sql = f"UPDATE {req.target_table} SET {col} = 'HASH_' || md5({col}) WHERE {req.target_id_col} = $1"
                    await conn.execute(sql, req.target_id_val)
            print("[DEBUG] Step 1: Target Database Updated.")
        finally:
            await conn.close()
    except Exception as e:
        print(f"[DEBUG] Step 1 FAILED: {e}")
        raise HTTPException(status_code=500, detail=f"Target DB Error: {str(e)}")

    # STEP 2: LOG TO AEGIS AUDIT DB
    try:
        aegis_conn = await asyncpg.connect(AEGIS_DB_DSN)
        try:
            cols_str = ", ".join([c['col'] for c in req.columns_to_clean])
            await aegis_conn.execute("""
                INSERT INTO audit_logs (target_db, target_table, target_pk_id, columns_cleaned, status)
                VALUES ($1, $2, $3, $4, 'SUCCESS')
            """, req.connection.db_name, req.target_table, req.target_id_val, cols_str)
            print("[DEBUG] Step 2: Audit Log Saved.")
        finally:
            await aegis_conn.close()
    except Exception as e:
        # We catch this error so the user still gets their result, even if logging fails
        print(f"[DEBUG] Step 2 FAILED (Check Aegis DB Password or Table): {e}")
        # Note: We continue execution!

    # STEP 3: GENERATE PDF
    try:
        pdf_bytes = create_certificate(req, str(datetime.datetime.now()))
        print("[DEBUG] Step 3: PDF Generated.")
        
        return StreamingResponse(
            io.BytesIO(pdf_bytes), 
            media_type="application/pdf", 
            headers={"Content-Disposition": "attachment; filename=certificate.pdf"}
        )
    except Exception as e:
        print(f"[DEBUG] Step 3 FAILED: {e}")
        raise HTTPException(status_code=500, detail=f"PDF Error: {str(e)}")